---
title: Create the test utility
weight: 3.5

### FIXED, DO NOT MODIFY
layout: learningpathall
---

## Test utility script

Now that you have your Intel nginx deployment running, you'll create a utility script to test and manage your nginx services across all architectures. This script will be used throughout the tutorial to test services, apply configurations, and access pods.

### Script functionality

The `nginx_util.sh` script provides three main functions:

- **`get intel|amd|arm|multiarch`** - Test nginx services and show which pod served the request
- **`put config`** - Apply performance-optimized nginx configuration and install btop monitoring tool
- **`login intel|amd|arm`** - Interactive bash access to architecture-specific pods

### Create the utility script

{{% notice Note %}}
The following utility `nginx_util.sh` is provided for convenience. 

It's a wrapper for kubectl, utilizing [curl](https://curl.se/).  

Make sure you have curl installed before running.
{{% /notice %}}

1. Use a text editor to copy the following shell script and save it to a file called `nginx_util.sh`:

```bash
#!/bin/bash

get_service_ip() {
    arch=$1
    svc_name="nginx-${arch}-svc"
    kubectl -nnginx get svc $svc_name -o jsonpath="{.status.loadBalancer.ingress[*]['ip', 'hostname']}"
}

get_request() {
    svc_ip=$1
    curl -s http://$svc_ip/ | grep "<title>Welcome to nginx!</title>"
}

apply_nginx_config() {
    NAMESPACE="nginx"
    
    echo "Applying custom nginx.conf to all nginx pods..."
    
    # Create the custom nginx.conf content
    kubectl create configmap nginx-config --from-literal=nginx.conf='
user  nginx;

error_log  /var/log/nginx/error.log notice;
pid        /run/nginx.pid;

worker_processes auto;
events {
    worker_connections  1024;
}

http {

    server {
        listen 80;

        location / {
            root /usr/share/nginx/html;
        }
    }
        # cache informations about FDs, frequently accessed files
    # can boost performance, but you need to test those values
    open_file_cache max=200000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    # access logs enabled for monitoring and debugging
    access_log /var/log/nginx/access.log;

    # copies data between one FD and other from within the kernel
    # faster than read() + write()
    sendfile on;

    # send headers in one piece, it is better than sending them one by one
    tcp_nopush on;

    # don'\''t buffer data sent, good for small data bursts in real time
    tcp_nodelay on;
    

    # allow the server to close connection on non responding client, this will free up memory
    reset_timedout_connection on;

    # request timed out -- default 60
    client_body_timeout 10;

    # if client stop responding, free up memory -- default 60
    send_timeout 2;

    # server will close connection after this time -- default 75
    keepalive_timeout 30;

    # number of requests client can make over keep-alive -- for testing environment
    keepalive_requests 100000;
}
' -n $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

    # Get all nginx deployments and update them
    for deployment in $(kubectl get deployments -n $NAMESPACE -o name | grep nginx); do
        deployment_name=$(echo $deployment | cut -d'/' -f2)
        echo "Updating $deployment_name..."
        
        # Add volume and volume mount to deployment
        kubectl patch deployment $deployment_name -n $NAMESPACE --type='json' -p='[
            {
                "op": "add",
                "path": "/spec/template/spec/volumes",
                "value": [{"name": "nginx-config", "configMap": {"name": "nginx-config"}}]
            },
            {
                "op": "add", 
                "path": "/spec/template/spec/containers/0/volumeMounts",
                "value": [{"name": "nginx-config", "mountPath": "/etc/nginx/nginx.conf", "subPath": "nginx.conf"}]
            }
        ]'
    done

    echo "Waiting for pods to restart with new configuration..."
    sleep 15

    # Install btop on all nginx pods
    echo "Installing btop on all nginx pods..."
    for pod in $(kubectl get pods -l app=nginx-multiarch -n $NAMESPACE -o name | sed 's/pod\///'); do
        echo "Installing btop on $pod..."
        kubectl exec -n $NAMESPACE $pod -- apt-get update -y >/dev/null 2>&1
        kubectl exec -n $NAMESPACE $pod -- apt-get install -y btop >/dev/null 2>&1
        echo "✓ btop installed on $pod"
    done

    echo "✅ Custom nginx.conf applied and btop installed on all pods!"
}

run_action() {
    action=$1
    arch=$2

    svc_ip=$(get_service_ip $arch)
    echo "Using service endpoint $svc_ip for $action on $(tput bold)$arch service$(tput sgr0)"

    case $action in
        get)
            # Make the request
            response=$(get_request $svc_ip)
            echo "Response: $response"
            
            # Wait a moment for logs to appear
            sleep 2
            
            # Find the most recent log entry with our curl user agent
            serving_pod=$(kubectl logs --timestamps -l app=nginx-multiarch -nnginx --prefix --since=5s | grep "curl/8.7.1" | tail -1 | sed 's/.*\[pod\/\([^\/]*\).*/\1/')
            if [ -n "$serving_pod" ]; then
                # Extract architecture from deployment name and bold it
                bold_pod=$(echo "$serving_pod" | sed "s/nginx-\([^-]*\)-deployment/nginx-$(tput bold)\1$(tput sgr0)-deployment/")
                echo "Served by: $bold_pod"
            else
                echo "Served by: Unable to determine"
            fi
            ;;
        *)
            echo "Invalid first argument. Use 'get'."
            exit 1
            ;;
    esac
}

case $1 in
    get)
        case $2 in
            intel|arm|amd|multiarch)
                run_action $1 $2
                ;;
            *)
                echo "Invalid second argument. Use 'intel', 'arm', 'amd', or 'multiarch'."
                exit 1
                ;;
        esac
        ;;
    put)
        case $2 in
            config)
                apply_nginx_config
                ;;
            *)
                echo "Invalid second argument. Use 'config'."
                exit 1
                ;;
        esac
        ;;
    login)
        case $2 in
            intel|arm|amd)
                # Get the pod for the specified architecture
                pod_name=$(kubectl get pods -l arch=$2 -nnginx -o name | sed 's/pod\///')
                if [ -n "$pod_name" ]; then
                    echo "Connecting to $(tput bold)$2$(tput sgr0) pod: $pod_name"
                    kubectl exec -it -nnginx $pod_name -- /bin/bash
                else
                    echo "No $2 pod found"
                    exit 1
                fi
                ;;
            *)
                echo "Invalid second argument. Use 'intel', 'arm', or 'amd'."
                exit 1
                ;;
        esac
        ;;
    *)
        echo "Invalid first argument. Use 'get', 'put', or 'login'."
        exit 1
        ;;
esac

echo
```

{{% notice Note %}}
This script supports all architectures (intel, arm, amd, multiarch) and will be used throughout the tutorial. You only need to create it once.
{{% /notice %}}

2. Make the script executable with the following command:

```bash
chmod 755 nginx_util.sh
```

The script conveniently bundles test and logging commands into a single place, making it easy to test, troubleshoot, and view services.

You can now use this utility script throughout the tutorial to test services, apply configurations, and access pods across all architectures.
